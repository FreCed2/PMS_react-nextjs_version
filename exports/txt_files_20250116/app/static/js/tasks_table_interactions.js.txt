

import {
    setupModalLifecycleEvents,    // Handles lifecycle events for task modals
    initializeParentDropdown,     // Sets up the parent dropdown (e.g., Select2 initialization)
    refreshParentDropdown,        // Refreshes the parent dropdown based on task type changes
    setupModalEvents,             // Sets up event listeners for modals
    toggleModalSize,              // Toggles the modal between default and full-page size
    resetModalFields,             // Resets fields within the modal
    initNewTaskModal,             // Initializes "New Task" modal functionality
    initializeTaskModal,          // Configures and initializes the task modal
    openTaskModal,                // Opens a modal for a specific task
    populateTaskModal,            // Fills modal fields with task data
    setupContributorAssignment    // Manages contributor assignment actions
} from "./modals.js";

// Log to confirm the script's execution
console.log("Initializing tasks_table_interactions.js script...");


/* ======================== Document Initialization ======================== */

document.addEventListener("DOMContentLoaded", () => {
    console.log("Document is ready. Initializing application...");

    // Step 1: Retrieve CSRF token for secure requests
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
    if (!csrfToken) {
        console.error("CSRF token is missing. Application initialization halted.");
        return; // Stop initialization if token is missing
    }
    console.log("CSRF Token retrieved successfully:", csrfToken);

    // Step 2: Initialize modal features
    if (!window.taskModalInitialized) {
        console.log("Initializing task modal features...");
        initializeTaskModal(); // Setup modal lifecycle
        setupModalEvents(); // Setup specific modal events
        setupModalLifecycleEvents(); // Setup lifecycle-related events
        window.taskModalInitialized = true; // Prevent redundant re-initialization
        console.log("Task modal features initialized.");
    }

    // Step 3: Initialize TaskManager for task-related operations
    console.log("Initializing TaskManager...");
    TaskManager.init(csrfToken);

    // Step 4: Add event listener for "Open Task" links
    console.log("Setting up event listeners for task open links...");
    document.addEventListener("click", handleTaskOpenClick);

    // Step 5: Setup "Create Task" button
    const newTaskButton = document.getElementById("newTaskButton");
    if (newTaskButton) {
        newTaskButton.addEventListener("click", initNewTaskModal);
        console.log("Create Task button event listener added.");
    }

    // Step 6: Build parent-child relationships map
    console.log("Building parent-child relationships map...");
    const taskParentMap = new Map();
    function buildTaskParentMap() {
        taskParentMap.clear();
        document.querySelectorAll('tr[data-task-id]').forEach(row => {
            const taskId = parseInt(row.dataset.taskId, 10);
            const parentId = row.dataset.parentId ? parseInt(row.dataset.parentId, 10) : null;
            taskParentMap.set(taskId, parentId);
        });
        console.log("Parent-child relationships map built:", Array.from(taskParentMap.entries()));
    }
    buildTaskParentMap();

    // Step 7: Initialize event listeners for toggling child rows
    console.log("Initializing toggle listeners...");
    document.querySelectorAll(".toggle-details").forEach(button => {
        button.addEventListener("click", function () {
            const taskId = this.dataset.taskId;
            const childRows = document.querySelectorAll(`[data-parent-id="${taskId}"]`);
            const icon = this.querySelector("i");

            if (!childRows.length) {
                console.warn(`No child rows found for Task ID: ${taskId}`);
                return;
            }

            // Toggle child rows
            const isCurrentlyHidden = childRows[0].style.display === "none";
            toggleChildRows(taskId, isCurrentlyHidden);

            // Update toggle icon
            icon.classList.toggle("bi-chevron-down", isCurrentlyHidden);
            icon.classList.toggle("bi-chevron-right", !isCurrentlyHidden);
        });
    });

    // Step 8: Initialize toggle states for chevrons
    console.log("Initializing toggle states...");
    initializeToggleStates();

    // Step 9: Initialize drag-and-drop functionality
    console.log("Initializing drag-and-drop functionality...");
    initDragAndDrop(); // Ensure drag-and-drop setup
    console.log("Document initialization completed successfully.");
});

/* ======================== Event Handlers ======================== */

/**
 * Handles clicks on "Open" task links.
 * Prevents click events from propagating to other handlers and opens the modal.
 * @param {Event} event - The click event.
 */
let isModalOpening = false; // Flag to prevent multiple modals

function handleTaskOpenClick(event) {
    const target = event.target;

    if (target.classList.contains("task-open-link")) {
        event.stopPropagation(); // Prevent propagation to other click handlers
        event.preventDefault(); // Prevent default link behavior

        const taskId = target.dataset.taskId;
        console.log(`"Open" link clicked for Task ID: ${taskId}`);

        // Prevent multiple modals from opening simultaneously
        if (isModalOpening) {
            console.warn("Modal is already opening. Ignoring duplicate request.");
            return;
        }
        isModalOpening = true;

        // Attempt to open the task modal
        openTaskModal(taskId)
            .then(() => {
                console.log(`Modal successfully opened for Task ID: ${taskId}`);
            })
            .catch(error => {
                console.error(`Error opening task modal for Task ID: ${taskId}`, error);
                alert("Failed to open the task modal. Please try again.");
            })
            .finally(() => {
                isModalOpening = false; // Reset the flag
            });
    }
}

/* ======================== Initialization Functions ======================== */

/**
 * Initializes toggle arrows to match the visibility state of child task rows.
 * Ensures icons reflect the visibility of their associated child rows.
 */
function initializeToggleStates() {
    console.log("Initializing toggle states for task rows...");
    document.querySelectorAll(".toggle-details").forEach(button => {
        const taskId = button.dataset.taskId;
        const childRows = document.querySelectorAll(`[data-parent-id="${taskId}"]`);
        const icon = button.querySelector("i");

        if (!icon || !childRows.length) {
            console.warn(`No icon or child rows found for Task ID: ${taskId}`);
            return;
        }

        // Determine the visibility of any child row
        const isAnyChildVisible = Array.from(childRows).some(row => row.style.display !== "none");

        // Update the toggle icon to reflect the visibility state
        icon.classList.toggle("bi-chevron-down", isAnyChildVisible);
        icon.classList.toggle("bi-chevron-right", !isAnyChildVisible);
    });
    console.log("Toggle states initialized.");
}



/**
 * Adds a data-level attribute to each row based on its hierarchy.
 * The data-level attribute is used for styling nested tasks.
 */
function initializeRowLevels() {
    console.log("Initializing hierarchy levels for task rows...");
    document.querySelectorAll("tr[data-task-id]").forEach(row => {
        const level = getHierarchyLevel(row);
        row.setAttribute("data-level", level);
        console.log(`Set level ${level} for Task ID: ${row.dataset.taskId}`);
    });
}


/**
 * Initializes the TableSorter plugin for the task table.
 * Configures the plugin for sorting task columns with specific settings.
 */
function initTableSorter() {
    console.log("Initializing TableSorter for task table...");
    const taskTable = $(".table");

    if (!taskTable.length) {
        console.warn("Task table not found for TableSorter initialization.");
        return;
    }

    taskTable.tablesorter({
        theme: "bootstrap", // Apply Bootstrap theme to the table
        widgets: ["zebra"], // Add zebra striping for better visibility
        headers: {
            0: { sorter: false }, // Disable sorting for the first column
            1: { sorter: false }, // Disable sorting for the second column
            8: { sorter: false }, // Disable sorting for the actions column
        },
    });

    console.log("TableSorter initialized successfully.");
}

/**
 * Initializes toggle functionality for parent-child rows.
 * Sets up event listeners for toggle buttons to expand or collapse child rows.
 */
function initToggleDetails() {
    console.log("Initializing toggle functionality for parent-child rows...");

    document.querySelectorAll(".toggle-details").forEach(button => {
        button.addEventListener("click", function () {
            const taskId = this.dataset.taskId;
            const childRows = document.querySelectorAll(`[data-parent-id="${taskId}"]`);
            const icon = this.querySelector("i");

            if (!childRows.length) {
                console.warn(`No child rows found for Task ID: ${taskId}`);
                return;
            }

            // Check the current visibility state of the first child row
            const isCurrentlyHidden = childRows[0].style.display === "none";

            // Toggle child row visibility
            childRows.forEach(row => {
                row.style.display = isCurrentlyHidden ? "table-row" : "none";
            });

            // Update the toggle icon to reflect the visibility state
            icon.classList.toggle("bi-chevron-down", isCurrentlyHidden);
            icon.classList.toggle("bi-chevron-right", !isCurrentlyHidden);

            console.log(`Toggled child rows for Task ID: ${taskId}, Show: ${isCurrentlyHidden}`);
        });
    });

    console.log("Toggle functionality initialized.");
}

/* ======================== Utility Functions ======================== */


/**
 * Builds the `taskParentMap` from the DOM structure.
 * This map is used to maintain parent-child relationships dynamically.
 */
function buildTaskParentMap() {
    console.log("Building Task Parent Map...");
    taskParentMap.clear(); // Clear existing map to ensure a fresh build

    // Iterate over all task rows to populate the map
    document.querySelectorAll("tr[data-task-id]").forEach(row => {
        const taskId = parseInt(row.dataset.taskId, 10);
        const parentId = row.dataset.parentId ? parseInt(row.dataset.parentId, 10) : null;

        taskParentMap.set(taskId, parentId);
    });

    console.log("Task Parent Map built successfully:", Array.from(taskParentMap.entries()));
}

/**
 * Rebuilds the `taskParentMap` to reflect dynamic changes in the DOM.
 * This function should be called after operations like drag-and-drop or task deletion.
 */
function rebuildTaskParentMap() {
    console.log("Rebuilding Task Parent Map...");
    buildTaskParentMap();
}

/**
 * Determines the hierarchy level of a task row.
 * Used for styling and enforcing nesting rules dynamically.
 * @param {HTMLElement} row - The task row to analyze.
 * @returns {number} - The hierarchy level (1 for top-level, 2 for nested, etc.).
 */
function getHierarchyLevel(row) {
    let level = 1; // Default level for top-level tasks
    let parentId = row.getAttribute("data-parent-id");

    while (parentId) {
        level++;
        const parentRow = document.querySelector(`[data-task-id="${parentId}"]`);
        parentId = parentRow ? parentRow.getAttribute("data-parent-id") : null;
    }

    return level;
}

/**
 * Updates the `taskParentMap` dynamically when a task's parent changes.
 * Ensures the map remains consistent with the DOM structure.
 * @param {number} taskId - ID of the task being updated.
 * @param {number|null} parentId - New parent ID, or `null` if no parent.
 */
function updateTaskParentMap(taskId, parentId) {
    console.log(`Updating Task Parent Map: Task ${taskId} -> Parent ${parentId}`);
    taskParentMap.set(taskId, parentId);
}

/**
 * Highlights a task row temporarily to indicate successful changes.
 * Useful for visual feedback after save or reorder operations.
 * @param {number} taskId - ID of the task to highlight.
 */
function highlightTask(taskId) {
    const taskRow = document.querySelector(`tr[data-task-id="${taskId}"]`);
    if (taskRow) {
        taskRow.classList.add("highlight");
        setTimeout(() => taskRow.classList.remove("highlight"), 2000);
    } else {
        console.warn(`Task row not found for ID: ${taskId}`);
    }
}

/**
 * Toggles the visibility of child rows when a parent row is toggled.
 * @param {string} parentId - The ID of the parent task.
 * @param {boolean} show - Whether to show or hide the child rows.
 */
function toggleChildRows(parentId, show) {
    console.log(`Toggling child rows for Parent ID: ${parentId}, Show: ${show}`);
    const childRows = document.querySelectorAll(`[data-parent-id="${parentId}"]`);

    childRows.forEach(row => {
        row.style.display = show ? "table-row" : "none";

        const icon = row.querySelector(".toggle-details i");
        if (icon) {
            icon.classList.toggle("bi-chevron-down", show);
            icon.classList.toggle("bi-chevron-right", !show);
        }

        const nestedChildId = row.dataset.taskId;
        if (nestedChildId) {
            toggleChildRows(nestedChildId, show); // Recursively toggle nested child rows
        }
    });
}

/**
 * Sets up tooltips on elements with the `data-bs-toggle="tooltip"` attribute.
 * Initializes Bootstrap tooltips for elements with tooltip attributes.
 * This function is called after the page loads to ensure consistency.
 */
function setupTooltips() {
    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
    tooltipTriggerList.forEach(trigger => new bootstrap.Tooltip(trigger));
}

/**
 * Configures theme toggle functionality.
 * This function is called after the page loads to ensure consistency.
 * The theme is stored as a data attribute on the HTML element.
 */
function setupThemeToggle() {
    const themeButton = document.getElementById("themeToggle");
    if (themeButton) {
        themeButton.addEventListener("click", () => {
            const htmlElement = document.documentElement;
            const currentTheme = htmlElement.getAttribute("data-bs-theme");
            htmlElement.setAttribute("data-bs-theme", currentTheme === "dark" ? "light" : "dark");
        });
    }
}

/* ======================== Modal Management ======================== */

/**
 * Refreshes the specific row from the backend.
 * Updates contributor and other relevant fields dynamically.
 * This function is called after a task is saved or updated.
 * It fetches the latest task data from the backend.
 * It updates the contributor field in the task row.
 * IT DOES NOT CONTAIN ANY LOGIC FOR UPDATING THE PARENT TASK FIELD.
 * IT DOES NOT WORK 
 * @param {number} taskId - The ID of the task to refresh.
 */
async function refreshTaskRow(taskId) {
    try {
        const response = await fetch(`/api/tasks/${taskId}`);
        const data = await response.json();
        const taskRow = document.getElementById(`task-${taskId}`);
        if (taskRow && data) {
            const contributorCell = taskRow.querySelector("td[data-contributor-column]");
            if (contributorCell) {
                contributorCell.textContent = data.contributor_name || "Unassigned";
            }
        }
    } catch (error) {
        console.error("Error refreshing task row:", error);
    }
}

/* ======================== Task Deletion Workflow ======================== */

/**
 * Configures task deletion with SweetAlert2 confirmation.
 * Displays a modal to choose whether to delete child tasks.
 * MUST REMOVE THE VERY ANNOYING ANIMATION OF SWEETALERT2
 * Sends a DELETE request to the backend to delete the task.
 * This function is called after the page loads to ensure consistency.
 * The task deletion logic sends a DELETE request to the backend, 
 * updates the task list after deletion and displays a success or error message.
 */
function setupDeleteTaskLogic(csrfToken) {
    document.querySelectorAll(".delete-task-btn").forEach(button => {
        button.addEventListener("click", function () {
            const taskId = this.dataset.taskId;

            Swal.fire({
                title: "Are you sure?",
                text: "You can choose to delete its child tasks or keep them.",
                icon: "warning",
                showCancelButton: true,
                showDenyButton: true,
                confirmButtonText: "Delete child tasks",
                denyButtonText: "Keep subtasks",
                cancelButtonText: "Cancel",
                confirmButtonColor: "#d33",
                denyButtonColor: "#3085d6",
                cancelButtonColor: "#6c757d",
            }).then((result) => {
                if (result.isConfirmed) {
                    deleteTask(taskId, true, csrfToken);
                    rebuildTaskParentMap(); // Reflect the new parent-child relationships
                } else if (result.isDenied) {
                    deleteTask(taskId, false, csrfToken);
                    rebuildTaskParentMap(); // Reflect the new parent-child relationships
                }
            });
        });
    });
}

/**
 * This function is called when the user confirms the deletion.
 * It sends a DELETE request to the backend to delete the task.
 * The task is deleted along with its children if specified.
 * The `taskId` parameter is the ID of the task to delete.
 * The `deleteChildren` parameter determines whether to delete children.
 * The `csrfToken` parameter is used to send requests securely.
 */
async function deleteTask(taskId, deleteChildren, csrfToken) {
    try {
        const response = await fetch(`/api/tasks/delete/${taskId}?confirm_children=${deleteChildren}`, {
            method: "DELETE",
            headers: {
                "X-CSRFToken": csrfToken,
            },
        });

        if (response.ok) {
            const result = await response.json();
            Swal.fire("Deleted!", result.message, "success").then(() => {
                location.reload();
            });
        } else {
            const result = await response.json();
            Swal.fire("Error!", result.error, "error");
        }
    } catch (error) {
        console.error("Error deleting task:", error);
        Swal.fire("Error!", "An unexpected error occurred.", "error");
    }
}



export const TaskManager = {
    init: function (csrfToken) { // Accept csrfToken as a parameter
        this.csrfToken = csrfToken;
        this.initTaskParentMap(); // Initialize taskParentMap 
        this.initFilters();
        this.initTaskInteraction();
        this.initNewTaskModal();
        this.initSaveTask();
        this.initDragAndDrop(); // Initialize drag-and-drop functionality
    },

    initFilters: function () {
        const filters = ['#project_filter', '#task_type_filter', '#completion_status_filter'];
        filters.forEach(selector => {
            const filterElement = document.querySelector(selector);
            if (filterElement) {
                filterElement.addEventListener('change', () => {
                    const params = new URLSearchParams(window.location.search);
                    params.set(selector.replace('#', '').replace('_filter', ''), filterElement.value);
                    window.location.search = params.toString();
                });
            }
        });

        const clearButton = document.getElementById('clear_filters');
        if (clearButton) {
            clearButton.addEventListener('click', () => {
                window.location.href = "{{ url_for('tasks.list_tasks') }}";
            });
        }
    },

    initTaskInteraction: function () {
        /* document.addEventListener("click", async (event) => {
            if (event.target.classList.contains("task-open-link")) {
                event.preventDefault();
                const taskId = event.target.dataset.taskId;
                try {
                    await openTaskModal(taskId); // Ensure `openTaskModal` is defined and imported
                } catch (error) {
                    console.error("Error opening task modal:", error);
                }
            }
        }); */
    },

    initNewTaskModal: function () {
        const newTaskButton = document.getElementById("newTaskButton");
        if (newTaskButton) {
            newTaskButton.addEventListener("click", () => {
                const taskForm = document.getElementById("taskForm");
                if (taskForm) {
                    taskForm.reset();
                }
                const taskIdField = document.getElementById("task-id");
                const modalLabel = document.getElementById("createTaskModalLabel");
                if (taskIdField) taskIdField.value = "";
                if (modalLabel) modalLabel.textContent = "Create Task";

                rebuildTaskParentMap(); // Reflect the new parent-child relationships
            });
        }
    },

    initSaveTask: function () {
        const taskForm = document.getElementById("taskForm");
        if (taskForm) {
            taskForm.addEventListener("submit", async (event) => {
                event.preventDefault(); // Prevent default form submission
                const formData = new FormData(taskForm);
                const payload = Object.fromEntries(formData); 

                const parentTaskField = document.getElementById("taskParent");
                if (parentTaskField) {
                    payload['parent_id'] = parentTaskField.value || null; 
                }

                payload['name'] = payload['title']; 

                try {
                    const response = await fetch("/api/tasks", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "X-CSRFToken": this.csrfToken,
                        },
                        body: JSON.stringify(payload), 
                    });

                    if (response.ok) {
                        const result = await response.json();
                        rebuildTaskParentMap(); // Reflect the new parent-child relationships
                        console.log("Task saved successfully:", result);
                        location.reload();// 
                    } else {
                        const errorData = await response.json();
                        console.error("Error saving task:", errorData);
                        alert(`Failed to save the task: ${errorData.message || "Unknown error"}`);
                    }
                } catch (error) {
                    console.error("Unexpected error saving task:", error);
                    alert("An unexpected error occurred. Please try again.");
                }
            });
        }
    },

/* ======================== Drag and Drop section ======================== */

    // Initialize a global map for task relationships
    taskParentMap: new Map(),

    // Build the taskParentMap from the DOM
    initTaskParentMap: function () {
        console.log("Initializing Task Parent Map...");
        const rows = document.querySelectorAll("tr[data-task-id]");

        rows.forEach((row) => {
            const taskId = parseInt(row.dataset.taskId, 10);
            const parentId = parseInt(row.dataset.parentId, 10) || null;
            this.taskParentMap.set(taskId, parentId);
        });

        console.log("Task Parent Map initialized:", Array.from(this.taskParentMap.entries()));
    },

    // Update the map dynamically after drag-and-drop
    updateTaskParentMap: function (taskId, parentId) {
        console.log(`Updating Task Parent Map: Task ${taskId} -> Parent ${parentId}`);
        this.taskParentMap.set(taskId, parentId);
    },

    initDragAndDrop: function () {
        if (window.isDragAndDropInitialized) {
            console.log("Drag-and-drop is already initialized.");
            return;
        }

        console.log("Initializing drag-and-drop within TaskManager...");
        console.log("CSRF Token in initDragAndDrop:", this.csrfToken);
        const tableBody = document.querySelector("tbody");
        if (!tableBody) {
            console.warn("Task table body not found for drag-and-drop initialization");
            return;
        }

        // Initialize Sortable.js for drag-and-drop functionality
        Sortable.create(tableBody, {
            handle: ".task-row", // Only draggable via `.task-row` elements
            animation: 150, // Smooth animation
            filter: ".task-open-link", // Prevent dragging on task links
            preventOnFilter: true, // Prevent drag if filtered element is clicked
            onEnd: async (event) => {
                try {
                    console.log("Drag-and-drop operation started...");

                    let draggedRow = event.item; // The row that was dragged
                    const taskId = parseInt(draggedRow.dataset.taskId, 10);
                    
                    // Rebuild the parent-child relationships after drag-and-drop
                    const rows = Array.from(event.from.querySelectorAll(".task-row"));
                    rows.sort((a, b) => a.offsetTop - b.offsetTop); // Ensure rows are sorted by DOM position
                    const reorderedTasks = [];

                    rows.forEach((row, index) => {
                        const taskId = parseInt(row.dataset.taskId, 10);

                        // Determine parent ID using the taskParentMap or row's dataset
                        let parentId = this.taskParentMap.get(taskId) || null;

                        // Update parent ID dynamically based on the DOM structure
                        const previousRow = row.previousElementSibling;
                        if (previousRow && parseInt(previousRow.dataset.level, 10) < parseInt(row.dataset.level, 10)) {
                            parentId = parseInt(previousRow.dataset.taskId, 10);
                        } else if (!previousRow || parseInt(previousRow.dataset.level, 10) >= parseInt(row.dataset.level, 10)) {
                            parentId = null; // No parent row above or invalid hierarchy
                        }

                        // Fallback to taskParentMap for safety
                        if (!parentId) {
                            parentId = this.taskParentMap.get(taskId) || null;
                        }

                        // Update the taskParentMap dynamically
                        this.updateTaskParentMap(taskId, parentId);

                        // Prepare the task payload for backend submission
                        reorderedTasks.push({
                            id: taskId,
                            sort_order: index + 1,
                            parent_id: parentId,
                        });
                    });

                    console.log("Updated Task Parent Map:", Array.from(this.taskParentMap.entries()));
                    console.log("Final Payload (Before Submission):", JSON.stringify(reorderedTasks));

                    // Send the payload to the backend
                    const response = await fetch("/tasks/reorder_subtasks", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "X-CSRFToken": this.csrfToken, // Ensure CSRF token is included
                        },
                        body: JSON.stringify({ ordered_tasks: reorderedTasks }),
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error("Error reordering tasks:", errorData);
                        alert(`Failed to reorder tasks: ${errorData.message || "Unknown error"}`);
                        return;
                    }

                    const data = await response.json();
                    console.log("Task reordering successful:", data);

                } catch (error) {
                    console.error("Error during drag-and-drop operation:", error);
                    alert("An unexpected error occurred while reordering tasks.");
                }
            },
        });

        window.isDragAndDropInitialized = true;
        console.log("Drag-and-drop initialized successfully.");
    },
};

// Expose the TaskManager object globally
window.TaskManager = TaskManager;