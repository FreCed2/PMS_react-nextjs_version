import logging
import traceback
from flask import Blueprint, request, jsonify
from datetime import datetime
from app.forms.forms import csrf
from app.tasks.utils import TaskService
from app.models import Project
from app.tasks.models import Task
from app.extensions.db import db

logger = logging.getLogger(__name__)  # Creates a logger for the current module
logger.debug("This is a debug message from the api_routes module")

api = Blueprint('api', __name__)  # Create a Blueprint for API routes

@csrf.exempt
@api.route('/calculate_completion_percentage/<int:project_id>', methods=['GET'])
def calculate_completion_percentage_api(project_id):
    """
    API endpoint to calculate the completion percentage of a project.
    """
    # Retrieve the project
    project = Project.query.get(project_id)
    if not project:
        return jsonify({"error": f"Project with ID {project_id} not found."}), 404

    # Use TaskService to calculate completion percentage
    completion_percentage = TaskService.calculate_completion_percentage(project)

    # Return the result as JSON
    return jsonify({"completion_percentage": completion_percentage})

@api.route('/delete_project/<int:project_id>', methods=['DELETE'])
def api_delete_project(project_id):
    """
    API endpoint to delete a project and its related tasks.
    """
    # Use TaskService to delete the project
    success, message = TaskService.delete_project_and_tasks(project_id)
    if success:
        return jsonify({'success': True, 'message': message}), 200
    else:
        return jsonify({'success': False, 'message': message}), 500

@api.route('/tasks/<int:task_id>', methods=['GET'])
def get_task_details(task_id):
    """
    Fetch task details by ID and return as JSON using the TaskService utility method.
    """
    logger.info(f"Fetching task details for Task ID {task_id}.")

    try:
        # Fetch the task as a dictionary using TaskService
        task_data = TaskService.fetch_task_as_dict(task_id)

        logger.info(f"Task details fetched successfully for Task ID {task_id}.")
        return jsonify(task_data), 200
    except ValueError as e:
        logger.error(f"Task not found: {e}")
        return jsonify({"error": str(e)}), 404
    except Exception as e:
        logger.error(f"Error fetching task details for Task ID {task_id}: {str(e)}")
        return jsonify({
            "error": "An unexpected error occurred while fetching task details.",
            "details": str(e)
        }), 500


def validate_task_payload(data):
    """Validates task payload for required fields and hierarchy rules."""
    required_fields = ['title', 'project_id', 'task_type']
    missing_fields = [field for field in required_fields if field not in data]
    if missing_fields:
        return False, f"Missing required fields: {', '.join(missing_fields)}"

    try:
        # Safely convert story_points and parent_id to integers or None
        data['story_points'] = int(data['story_points']) if data.get('story_points') and str(data['story_points']).isdigit() else 0
        data['parent_id'] = int(data['parent_id']) if data.get('parent_id') and str(data['parent_id']).isdigit() else None

        # Enforce hierarchy validation
        if data['task_type'] == "Epic" and data['parent_id']:
            return False, "Epics cannot have a parent task."

        if data['task_type'] == "User Story" and data['parent_id']:
            parent_task = Task.query.get(data['parent_id'])
            if not parent_task or parent_task.task_type != "Epic":
                return False, "User Stories must have an Epic as a parent."

        if data['task_type'] == "Subtask" and data['parent_id']:
            parent_task = Task.query.get(data['parent_id'])
            if not parent_task or parent_task.task_type != "User Story":
                return False, "Subtasks must have a User Story as a parent."
    except ValueError as e:
        return False, "Fields 'story_points' and 'parent_id' must be integers."

    return True, None

@csrf.exempt
@api.route('/tasks', methods=['POST'])
def save_task():
    """
    Create a new task or update an existing one.
    """
    logger.debug("Stack trace", exc_info=True)
    
    try:
        # Ensure the request contains JSON
        data = request.get_json()
        logger.debug(f"Raw payload received: {request.data}")  # Log raw data
        logger.debug(f"Parsed payload: {data}")  # Log parsed data
        logger.debug(f"Contributor ID in payload: {data.get('contributor_id')}") # Debug contributor ID in payload
        
        if not data:
            logger.error("No JSON payload received")
            return jsonify({"error": "Invalid input. Expected JSON payload."}), 400
        
        # Map 'title' to 'name' for compatibility
        data['name'] = data.get('name') or data.get('title')
        if not data['name']:
            logger.error("Task name is missing in payload")
            return jsonify({"error": "Missing required fields: name"}), 400

        
        logger.info(f"Received task data: {data}")
        
        # Validate the payload
        valid, error_message = validate_task_payload(data)
        logger.debug(f"Validation result: valid={valid}, error_message={error_message}")
        if not valid:
            logger.error(f"Validation error: {error_message}")
            return jsonify({"error": error_message}), 400

        # Additional parent_id hierarchy validation
        if data['parent_id']:
            parent_task = Task.query.get(data['parent_id'])
            if not parent_task:
                logger.error("Invalid parent task ID provided.")
                return jsonify({"error": "Parent task does not exist."}), 400

            # Validate hierarchy rules
            if data['task_type'] == "User Story" and parent_task.task_type != "Epic":
                return jsonify({"error": "User Stories must have an Epic as a parent."}), 400
            if data['task_type'] == "Subtask" and parent_task.task_type != "User Story":
                return jsonify({"error": "Subtasks must have a User Story as a parent."}), 400

        # Check if updating an existing task
        task_id = data.get('id') or data.get('task_id')  # Support both 'id' and 'task_id'
        if task_id:
            logger.debug(f"Attempting to update task with ID {task_id}")
            task = Task.query.get(task_id)
            
            if not task:
                logger.error(f"Task with ID {task_id} not found")
                return jsonify({"error": f"Task with ID {task_id} not found."}), 404
            
            # Add this to validate the contributor ID:
            if 'contributor_id' in data and data['contributor_id']:
                try:
                    data['contributor_id'] = int(data['contributor_id'])
                except ValueError:
                    logger.error("Contributor ID must be an integer.")
                    return jsonify({"error": "Invalid contributor ID"}), 400

            # Update existing task fields
            task.name = data['name']
            task.description = data.get('description')  # Optional field
            task.project_id = data['project_id']
            task.story_points = data['story_points']
            task.parent_id = data['parent_id']
            task.task_type = data['task_type']  # Ensure task_type is updated
            task.contributor_id = data.get('contributor_id')  # Optional
            task.completed = data.get('completed', False)
            task.updated_at = datetime.utcnow()
            
            # Preserve the current sort_order unless it's explicitly passed in the payload
            if 'sort_order' in data and data['sort_order'] is not None:
                task.sort_order = data['sort_order']
            logger.info(f"Task with ID {task_id} updated successfully")
        else:
            # Create a new task
            logger.info(f"Creating a new task with the following data: {data}")
            task = Task(
                name=data['name'],
                description=data.get('description'),  # Optional
                project_id=data['project_id'],
                story_points=data['story_points'],
                parent_id=data['parent_id'],
                task_type=data['task_type'],
                contributor_id=data.get('contributor_id'),  # Optional
                completed=data.get('completed', False),
                created_at=datetime.utcnow(),
                # Assign sort_order if provided; otherwise default to 0
                sort_order=data.get('sort_order', 0)
            )
            db.session.add(task)
            logger.info(f"New task created: {task.name}")

        # Safe commit
        logger.debug("Committing changes to the database.")
        db.session.commit()
        logger.debug("Changes committed successfully.")

        # Return a success response with contributor name
        return jsonify({
            "success": True,
            "task_id": task.id,
            "contributor_name": task.contributor.name if task.contributor else "Unassigned"
        }), 200
        
    except Exception as e:
        logger.error(f"Error saving task: {str(e)}")
        db.session.rollback()
        return jsonify({
            "error": "An unexpected error occurred while saving the task.",
            "details": str(e)
        }), 500

        
@api.route('/tasks/delete/<int:task_id>', methods=['DELETE'])
def delete_task(task_id):
    """
    API endpoint to delete a task. Optionally, delete its child tasks as well.
    :param task_id: ID of the task to be deleted.
    :return: JSON response with success or error message.
    """
    try:
        # Fetch the task
        task = Task.query.get(task_id)
        if not task:
            logger.error(f"Task with ID {task_id} not found.")
            return jsonify({"error": f"Task with ID {task_id} not found."}), 404

        # Confirm deletion of children via query param
        confirm_children = request.args.get('confirm_children', 'false').lower() == 'true'

        # Use helper method to delete task
        task.delete_with_children(confirm=confirm_children)
        return jsonify({"message": f"Task {task_id} and its children have been deleted."}), 200

    except Exception as e:
        logger.error(f"Error deleting task {task_id}: {str(e)}")
        return jsonify({"error": "An error occurred while deleting the task."}), 500
    