import logging
import traceback
from flask import Blueprint, request, jsonify
from datetime import datetime
from app.forms.forms import csrf
from app.tasks.utils import TaskService
from app.models import Project, Contributor
from app.tasks.models import Task
from app.extensions.db import db

logger = logging.getLogger(__name__)  # Creates a logger for the current module
logger.debug("This is a debug message from the api_routes module")

api = Blueprint('api', __name__)  # Create a Blueprint for API routes

@csrf.exempt
@api.route('/calculate_completion_percentage/<int:project_id>', methods=['GET'])
def calculate_completion_percentage_api(project_id):
    """
    API endpoint to calculate the completion percentage of a project.
    """
    # Retrieve the project
    project = Project.query.get(project_id)
    if not project:
        return jsonify({"error": f"Project with ID {project_id} not found."}), 404

    # Use TaskService to calculate completion percentage
    completion_percentage = TaskService.calculate_completion_percentage(project)

    # Return the result as JSON
    return jsonify({"completion_percentage": completion_percentage})

@api.route('/delete_project/<int:project_id>', methods=['DELETE'])
def api_delete_project(project_id):
    """
    API endpoint to delete a project and its related tasks.
    """
    # Use TaskService to delete the project
    success, message = TaskService.delete_project_and_tasks(project_id)
    if success:
        return jsonify({'success': True, 'message': message}), 200
    else:
        return jsonify({'success': False, 'message': message}), 500

@api.route('/tasks/<int:task_id>', methods=['GET'])
def get_task_details(task_id):
    """
    Fetch task details by ID and return as JSON using the TaskService utility method.
    """
    logger.info(f"Fetching task details for Task ID {task_id}.")

    try:
        # Fetch the task as a dictionary using TaskService
        task_data = TaskService.fetch_task_as_dict(task_id)

        logger.info(f"Task details fetched successfully for Task ID {task_id}.")
        return jsonify(task_data), 200
    except ValueError as e:
        logger.error(f"Task not found: {e}")
        return jsonify({"error": str(e)}), 404
    except Exception as e:
        logger.error(f"Error fetching task details for Task ID {task_id}: {str(e)}")
        return jsonify({
            "error": "An unexpected error occurred while fetching task details.",
            "details": str(e)
        }), 500


def validate_task_payload(data):
    """Validates task payload for required fields and hierarchy rules."""
    required_fields = ['title', 'project_id', 'task_type']
    missing_fields = [field for field in required_fields if field not in data]
    if missing_fields:
        return False, f"Missing required fields: {', '.join(missing_fields)}"

    try:
        # Safely convert story_points and parent_id to integers or None
        data['story_points'] = int(data['story_points']) if data.get('story_points') and str(data['story_points']).isdigit() else 0
        data['parent_id'] = int(data['parent_id']) if data.get('parent_id') and str(data['parent_id']).isdigit() else None

        # Enforce hierarchy validation
        if data['task_type'] == "Epic" and data['parent_id']:
            return False, "Epics cannot have a parent task."

        if data['task_type'] == "User Story" and data['parent_id']:
            parent_task = Task.query.get(data['parent_id'])
            if not parent_task or parent_task.task_type != "Epic":
                return False, "User Stories must have an Epic as a parent."

        if data['task_type'] == "Subtask" and data['parent_id']:
            parent_task = Task.query.get(data['parent_id'])
            if not parent_task or parent_task.task_type != "User Story":
                logger.error(f"Invalid parent for Subtask: parent_id={data['parent_id']}, parent_type={parent_task.task_type if parent_task else 'None'}")
                return False, "Subtasks must have a User Story as a parent."
    except ValueError as e:
        return False, "Fields 'story_points' and 'parent_id' must be integers."

    return True, None


@csrf.exempt
@api.route('/tasks', methods=['POST'])
def save_task():
    """
    API route to create a new task or update an existing one.
    Handles validation, parent-child hierarchy rules, and database interactions.
    
    Expected Payload:
    - title (string): Task title (mapped to 'name')
    - description (string, optional): Task description
    - project_id (int): Associated project ID
    - task_type (string): Task type (e.g., "Epic", "User Story", "Subtask")
    - parent_id (int, optional): ID of the parent task (if applicable)
    - story_points (int, optional): Task story points
    - contributor_id (int, optional): ID of the assigned contributor
    - completed (bool, optional): Completion status
    - sort_order (int, optional): Sort order of the task

    Returns:
    - JSON response with success or error details.
    """
    logger.debug("Entering save_task route")

    try:
        # Ensure the request contains JSON
        data = request.get_json()
        logger.debug(f"Raw payload received: {request.data}")
        logger.debug(f"Parsed payload: {data}")
        

        if not data:
            logger.error("No JSON payload received")
            return jsonify({"error": "Invalid input. Expected JSON payload."}), 400

        # Map 'title' to 'name' for compatibility
        data['name'] = data.get('name') or data.get('title')
        if not data['name']:
            logger.error("Task name is missing in payload")
            return jsonify({"error": "Missing required fields: name"}), 400

        logger.info(f"Received task data: {data}")
        

        # Validate the payload
        valid, error_message = validate_task_payload(data)
        logger.debug(f"Validation result: valid={valid}, error_message={error_message}")
        if not valid:
            logger.error(f"Validation error: {error_message}")
            return jsonify({"error": error_message}), 400

        # Additional parent_id hierarchy validation
        if data['parent_id']:
            try:
                TaskService.validate_hierarchy(task=Task(
                    task_type=data['task_type'],
                    parent_id=data['parent_id']
                ))
            except ValueError as ve:
                logger.error(f"Hierarchy validation failed: {str(ve)}")
                return jsonify({"error": str(ve)}), 400

        # Check if updating an existing task
        task_id = data.get('id') or data.get('task_id')  # Support both 'id' and 'task_id'
        if task_id:
            logger.debug(f"Attempting to update task with ID {task_id}")
            task = Task.query.get(task_id)
            
            if not task:
                logger.error(f"Task with ID {task_id} not found")
                return jsonify({"error": f"Task with ID {task_id} not found."}), 404

            # Validate contributor ID
            if 'contributor_id' in data and data['contributor_id']:
                try:
                    data['contributor_id'] = int(data['contributor_id'])
                except ValueError:
                    logger.error("Contributor ID must be an integer.")
                    return jsonify({"error": "Invalid contributor ID"}), 400

            # Update existing task fields
            task.name = data['name']
            task.description = data.get('description')  # Optional field
            task.project_id = data['project_id']
            task.story_points = data['story_points']
            task.parent_id = data['parent_id']
            task.task_type = data['task_type']
            task.contributor_id = data.get('contributor_id')  # Optional
            task.completed = data.get('completed', False)
            task.updated_at = datetime.utcnow()
            
            # Update sort order if provided
            if 'sort_order' in data:
                task.sort_order = data['sort_order']

            logger.info(f"Task with ID {task_id} updated successfully")
        else:
            # Create a new task
            logger.info("Creating a new task")
            task = Task(
                name=data['name'],
                description=data.get('description'),  # Optional
                project_id=data['project_id'],
                story_points=data['story_points'],
                parent_id=data['parent_id'],
                task_type=data['task_type'],
                contributor_id=data.get('contributor_id'),  # Optional
                completed=data.get('completed', False),
                created_at=datetime.utcnow(),
                # Assign sort_order if provided; otherwise default to 0
                sort_order=data.get('sort_order', 0)
            )
            db.session.add(task)
            logger.info(f"New task created with name: {task.name}")

        # Commit changes to the database
        db.session.commit()
        logger.debug(f"Task {task.id} saved with parent_id: {task.parent_id}")
    
        # Return detailed response
        return jsonify({
            "message": "Task saved successfully",
            "task": {
                "id": task.id,
                "name": task.name,
                "description": task.description,
                "parent_id": task.parent_id,
                "type": task.task_type,
                "project_id": task.project_id,
                "contributor_name": task.contributor.name if task.contributor else "Unassigned",
                "contributor_id": task.contributor_id if task.contributor else None,
                "completed": task.completed,
                "sort_order": task.sort_order,
                "updated_at": task.updated_at.isoformat(),
                "created_at": task.created_at.isoformat(),
            }
        }), 200

    except Exception as e:
        logger.error(f"Error in save_task: {str(e)}", exc_info=True)
        db.session.rollback()
        return jsonify({"error": "An unexpected error occurred while saving the task."}), 500

        
@api.route('/tasks/delete/<int:task_id>', methods=['DELETE'])
def delete_task(task_id):
    """
    API endpoint to delete a task. Optionally, delete its child tasks as well.
    :param task_id: ID of the task to be deleted.
    :return: JSON response with success or error message.
    """
    try:
        # Fetch the task
        task = Task.query.get(task_id)
        if not task:
            logger.error(f"Task with ID {task_id} not found.")
            return jsonify({"error": f"Task with ID {task_id} not found."}), 404

        # Confirm deletion of children via query param
        confirm_children = request.args.get('confirm_children', 'false').lower() == 'true'

        # Use helper method to delete task
        task.delete_with_children(confirm=confirm_children)
        return jsonify({"message": f"Task {task_id} and its children have been deleted."}), 200

    except Exception as e:
        logger.error(f"Error deleting task {task_id}: {str(e)}")
        return jsonify({"error": "An error occurred while deleting the task."}), 500
    