

/*
import {
    setupModalLifecycleEvents,    // Handles lifecycle events for task modals
    initializeParentDropdown,     // Sets up the parent dropdown (e.g., Select2 initialization)
    refreshParentDropdown,        // Refreshes the parent dropdown based on task type changes
    setupModalEvents,             // Sets up event listeners for modals
    toggleModalSize,              // Toggles the modal between default and full-page size
    resetModalFields,             // Resets fields within the modal
    initNewTaskModal,             // Initializes "New Task" modal functionality
    initializeTaskModal,          // Configures and initializes the task modal
    openTaskModal,                // Opens a modal for a specific task
    populateTaskModal,            // Fills modal fields with task data
    setupContributorAssignment    // Manages contributor assignment actions
} from "./modals.js";
*/
// Log to confirm the script's execution
console.log("Initializing tasks_table_interactions.js script...");


/* ======================== Document Initialization ======================== */

document.addEventListener("DOMContentLoaded", () => {
    console.log("Document is ready. Initializing application...");

    // Step 1: Retrieve CSRF token for secure requests
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
    if (!csrfToken) {
        console.error("CSRF token is missing. Application initialization halted.");
        return; // Stop initialization if token is missing
    }
    console.log("CSRF Token retrieved successfully:", csrfToken);
    
    // Step 2: Initialize TaskManager if not already initialized
    if (!window.TaskManagerInitialized) {
        console.log("Initializing TaskManager...");
        TaskManager.init(csrfToken);
        window.TaskManagerInitialized = true; // Mark as initialized
    } else {
        console.warn("TaskManager has already been initialized. Skipping initialization.");
    }

    // Step 3: Initialize drag-and-drop functionality through TaskManager
    console.log("Initializing drag-and-drop...");
    TaskManager.initDragAndDrop(); // Correctly call the drag-and-drop initialization
 

    // Step 4: Initialize task modal features if not already initialized
    if (!window.taskModalInitialized) {
        console.log("Initializing task modal features...");
        initializeTaskModal(); // Setup modal lifecycle
        setupModalEvents(); // Setup specific modal events
        setupModalLifecycleEvents(); // Setup lifecycle-related events
        window.taskModalInitialized = true; // Prevent redundant re-initialization
        console.log("Task modal features initialized.");
    }

    // Step 5: Build parent-child relationships map
    console.log("Building parent-child relationships map...");
    TaskManager.initTaskParentMap(); // Delegate this logic to TaskManager

    // Step 6: Initialize toggle states for chevrons
    console.log("Initializing toggle states...");
    initializeToggleStates();

    // Step 7: Add event listener for "Open Task" links
    console.log("Setting up event listeners for task open links...");
    document.addEventListener("click", handleTaskOpenClick);

    // Step 8: Setup "Create Task" button
    const newTaskButton = document.getElementById("newTaskButton");
    if (newTaskButton) {
        newTaskButton.addEventListener("click", initNewTaskModal);
        console.log("Create Task button event listener added.");
    }

    // Step 9: Initialize event listeners for toggling child rows
    console.log("Initializing toggle listeners...");
    document.querySelectorAll(".toggle-details").forEach(button => {
        button.addEventListener("click", function () {
            const taskId = this.dataset.taskId;
            const childRows = document.querySelectorAll(`[data-parent-id="${taskId}"]`);
            const icon = this.querySelector("i");

            if (!childRows.length) {
                console.warn(`No child rows found for Task ID: ${taskId}`);
                return;
            }

            // Toggle child rows
            const isCurrentlyHidden = childRows[0].style.display === "none";
            toggleChildRows(taskId, isCurrentlyHidden);

            // Update toggle icon
            icon.classList.toggle("bi-chevron-down", isCurrentlyHidden);
            icon.classList.toggle("bi-chevron-right", !isCurrentlyHidden);
        });
    });

    console.log("Document initialization completed.");
});


/* ======================== Event Handlers ======================== */

/**
 * Handles clicks on "Open" task links.
 * Prevents click events from propagating to other handlers and opens the modal.
 * @param {Event} event - The click event.
 */
let isModalOpening = false; // Flag to prevent multiple modals

function handleTaskOpenClick(event) {
    const target = event.target;

    if (target.classList.contains("task-open-link")) {
        event.stopPropagation(); // Prevent propagation to other click handlers
        event.preventDefault(); // Prevent default link behavior

        const taskId = target.dataset.taskId;
        console.log(`"Open" link clicked for Task ID: ${taskId}`);

        // Prevent multiple modals from opening simultaneously
        if (isModalOpening) {
            console.warn("Modal is already opening. Ignoring duplicate request.");
            return;
        }
        isModalOpening = true;

        // Attempt to open the task modal
        openTaskModal(taskId)
            .then(() => {
                console.log(`Modal successfully opened for Task ID: ${taskId}`);
            })
            .catch(error => {
                console.error(`Error opening task modal for Task ID: ${taskId}`, error);
                alert("Failed to open the task modal. Please try again.");
            })
            .finally(() => {
                isModalOpening = false; // Reset the flag
            });
    }
}

/* ======================== Initialization Functions ======================== */

/**
 * Initializes toggle arrows to match the visibility state of child task rows.
 * Ensures icons reflect the visibility of their associated child rows.
 */
function initializeToggleStates() {
    console.log("Initializing toggle states for task rows...");
    document.querySelectorAll(".toggle-details").forEach(button => {
        const taskId = button.dataset.taskId;
        const childRows = document.querySelectorAll(`[data-parent-id="${taskId}"]`);
        const icon = button.querySelector("i");

        if (!icon || !childRows.length) {
            console.warn(`No icon or child rows found for Task ID: ${taskId}`);
            return;
        }

        // Determine the visibility of any child row
        const isAnyChildVisible = Array.from(childRows).some(row => row.style.display !== "none");

        // Update the toggle icon to reflect the visibility state
        icon.classList.toggle("bi-chevron-down", isAnyChildVisible);
        icon.classList.toggle("bi-chevron-right", !isAnyChildVisible);
    });
    console.log("Toggle states initialized.");
}



/**
 * Adds a data-level attribute to each row based on its hierarchy.
 * The data-level attribute is used for styling nested tasks.
 */
function initializeRowLevels() {
    console.log("Initializing hierarchy levels for task rows...");
    document.querySelectorAll("tr[data-task-id]").forEach(row => {
        const level = getHierarchyLevel(row);
        row.setAttribute("data-level", level);
        console.log(`Set level ${level} for Task ID: ${row.dataset.taskId}`);
    });
}


/**
 * Initializes the TableSorter plugin for the task table.
 * Configures the plugin for sorting task columns with specific settings.
 */
function initTableSorter() {
    console.log("Initializing TableSorter for task table...");
    const taskTable = $(".table");

    if (!taskTable.length) {
        console.warn("Task table not found for TableSorter initialization.");
        return;
    }

    taskTable.tablesorter({
        theme: "bootstrap", // Apply Bootstrap theme to the table
        widgets: ["zebra"], // Add zebra striping for better visibility
        headers: {
            0: { sorter: false }, // Disable sorting for the first column
            1: { sorter: false }, // Disable sorting for the second column
            8: { sorter: false }, // Disable sorting for the actions column
        },
    });

    console.log("TableSorter initialized successfully.");
}

/**
 * Initializes toggle functionality for parent-child rows.
 * Sets up event listeners for toggle buttons to expand or collapse child rows.
 */
function initToggleDetails() {
    console.log("Initializing toggle functionality for parent-child rows...");

    document.querySelectorAll(".toggle-details").forEach(button => {
        button.addEventListener("click", function () {
            const taskId = this.dataset.taskId;
            const childRows = document.querySelectorAll(`[data-parent-id="${taskId}"]`);
            const icon = this.querySelector("i");

            if (!childRows.length) {
                console.warn(`No child rows found for Task ID: ${taskId}`);
                return;
            }

            // Check the current visibility state of the first child row
            const isCurrentlyHidden = childRows[0].style.display === "none";

            // Toggle child row visibility
            childRows.forEach(row => {
                row.style.display = isCurrentlyHidden ? "table-row" : "none";
            });

            // Update the toggle icon to reflect the visibility state
            icon.classList.toggle("bi-chevron-down", isCurrentlyHidden);
            icon.classList.toggle("bi-chevron-right", !isCurrentlyHidden);

            console.log(`Toggled child rows for Task ID: ${taskId}, Show: ${isCurrentlyHidden}`);
        });
    });

    console.log("Toggle functionality initialized.");
}

/* ======================== Utility Functions ======================== */


/**
 * Determines the hierarchy level of a task row.
 * Used for styling and enforcing nesting rules dynamically.
 * @param {HTMLElement} row - The task row to analyze.
 * @returns {number} - The hierarchy level (1 for top-level, 2 for nested, etc.).
 */
function getHierarchyLevel(row) {
    let level = 1; // Default level for top-level tasks
    let parentId = row.getAttribute("data-parent-id");

    while (parentId) {
        level++;
        const parentRow = document.querySelector(`[data-task-id="${parentId}"]`);
        parentId = parentRow ? parentRow.getAttribute("data-parent-id") : null;
    }

    return level;
}

/**
 * Updates the `taskParentMap` dynamically when a task's parent changes.
 * Ensures the map remains consistent with the DOM structure.
 * @param {number} taskId - ID of the task being updated.
 * @param {number|null} parentId - New parent ID, or `null` if no parent.
 */
function updateTaskParentMap(taskId, parentId) {
    console.log(`Updating Task Parent Map: Task ${taskId} -> Parent ${parentId}`);
    taskParentMap.set(taskId, parentId);
}

/**
 * Highlights a task row temporarily to indicate successful changes.
 * Useful for visual feedback after save or reorder operations.
 * @param {number} taskId - ID of the task to highlight.
 */
function highlightTask(taskId) {
    const taskRow = document.querySelector(`tr[data-task-id="${taskId}"]`);
    if (taskRow) {
        taskRow.classList.add("highlight");
        setTimeout(() => taskRow.classList.remove("highlight"), 2000);
    } else {
        console.warn(`Task row not found for ID: ${taskId}`);
    }
}

/**
 * Toggles the visibility of child rows when a parent row is toggled.
 * @param {string} parentId - The ID of the parent task.
 * @param {boolean} show - Whether to show or hide the child rows.
 */
function toggleChildRows(parentId, show) {
    console.log(`Toggling child rows for Parent ID: ${parentId}, Show: ${show}`);
    const childRows = document.querySelectorAll(`[data-parent-id="${parentId}"]`);

    childRows.forEach(row => {
        row.style.display = show ? "table-row" : "none";

        const icon = row.querySelector(".toggle-details i");
        if (icon) {
            icon.classList.toggle("bi-chevron-down", show);
            icon.classList.toggle("bi-chevron-right", !show);
        }

        const nestedChildId = row.dataset.taskId;
        if (nestedChildId) {
            toggleChildRows(nestedChildId, show); // Recursively toggle nested child rows
        }
    });
}

/**
 * Sets up tooltips on elements with the `data-bs-toggle="tooltip"` attribute.
 * Initializes Bootstrap tooltips for elements with tooltip attributes.
 * This function is called after the page loads to ensure consistency.
 */
function setupTooltips() {
    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
    tooltipTriggerList.forEach(trigger => new bootstrap.Tooltip(trigger));
}

/**
 * Configures theme toggle functionality.
 * This function is called after the page loads to ensure consistency.
 * The theme is stored as a data attribute on the HTML element.
 */
function setupThemeToggle() {
    const themeButton = document.getElementById("themeToggle");
    if (themeButton) {
        themeButton.addEventListener("click", () => {
            const htmlElement = document.documentElement;
            const currentTheme = htmlElement.getAttribute("data-bs-theme");
            htmlElement.setAttribute("data-bs-theme", currentTheme === "dark" ? "light" : "dark");
        });
    }
}

/* ======================== Modal Management ======================== */

/**
 * Refreshes the specific row from the backend.
 * Updates contributor and other relevant fields dynamically.
 * This function is called after a task is saved or updated.
 * It fetches the latest task data from the backend.
 * It updates the contributor field in the task row.
 * IT DOES NOT CONTAIN ANY LOGIC FOR UPDATING THE PARENT TASK FIELD.
 * IT DOES NOT WORK 
 * @param {number} taskId - The ID of the task to refresh.
 */
async function refreshTaskRow(taskId) {
    try {
        const response = await fetch(`/api/tasks/${taskId}`);
        const data = await response.json();
        const taskRow = document.getElementById(`task-${taskId}`);
        if (taskRow && data) {
            const contributorCell = taskRow.querySelector("td[data-contributor-column]");
            if (contributorCell) {
                contributorCell.textContent = data.contributor_name || "Unassigned";
            }
        }
    } catch (error) {
        console.error("Error refreshing task row:", error);
    }
}

/* ======================== Task Deletion Workflow ======================== */

/**
 * Configures task deletion with SweetAlert2 confirmation.
 * Displays a modal to choose whether to delete child tasks.
 * MUST REMOVE THE VERY ANNOYING ANIMATION OF SWEETALERT2
 * Sends a DELETE request to the backend to delete the task.
 * This function is called after the page loads to ensure consistency.
 * The task deletion logic sends a DELETE request to the backend, 
 * updates the task list after deletion and displays a success or error message.
 */
function setupDeleteTaskLogic(csrfToken) {
    document.querySelectorAll(".delete-task-btn").forEach(button => {
        button.addEventListener("click", function () {
            const taskId = this.dataset.taskId;

            Swal.fire({
                title: "Are you sure?",
                text: "You can choose to delete its child tasks or keep them.",
                icon: "warning",
                showCancelButton: true,
                showDenyButton: true,
                confirmButtonText: "Delete child tasks",
                denyButtonText: "Keep subtasks",
                cancelButtonText: "Cancel",
                confirmButtonColor: "#d33",
                denyButtonColor: "#3085d6",
                cancelButtonColor: "#6c757d",
            }).then((result) => {
                if (result.isConfirmed) {
                    deleteTask(taskId, true, csrfToken);
                    TaskManager.rebuildTaskParentMap();
                } else if (result.isDenied) {
                    deleteTask(taskId, false, csrfToken);
                    TaskManager.rebuildTaskParentMap();
                }
            });
        });
    });
}

/**
 * This function is called when the user confirms the deletion.
 * It sends a DELETE request to the backend to delete the task.
 * The task is deleted along with its children if specified.
 * The `taskId` parameter is the ID of the task to delete.
 * The `deleteChildren` parameter determines whether to delete children.
 * The `csrfToken` parameter is used to send requests securely.
 */
async function deleteTask(taskId, deleteChildren, csrfToken) {
    try {
        const response = await fetch(`/api/tasks/delete/${taskId}?confirm_children=${deleteChildren}`, {
            method: "DELETE",
            headers: {
                "X-CSRFToken": csrfToken,
            },
        });

        if (response.ok) {
            const result = await response.json();
            Swal.fire("Deleted!", result.message, "success").then(() => {
                location.reload();
            });
        } else {
            const result = await response.json();
            Swal.fire("Error!", result.error, "error");
        }
    } catch (error) {
        console.error("Error deleting task:", error);
        Swal.fire("Error!", "An unexpected error occurred.", "error");
    }
}

/*---------------------------------TaskManager---------------------------------*/

window.TaskManager = {

    // Add this property
    taskParentMap: new Map(),

    init: function (csrfToken) { 
        this.csrfToken = csrfToken; // Store CSRF token globally in TaskManager
        this.initTaskParentMap(); // Initialize taskParentMap 
        console.log("TaskManager initialized with CSRF token:", this.csrfToken);
        this.initFilters();
        this.initTaskInteraction();
        this.initNewTaskModal();
        this.initSaveTask();
        this.initDragAndDrop(); // Initialize drag-and-drop functionality
    },

    initFilters: function () {
        const filters = ['#project_filter', '#task_type_filter', '#completion_status_filter'];
        filters.forEach(selector => {
            const filterElement = document.querySelector(selector);
            if (filterElement) {
                filterElement.addEventListener('change', () => {
                    const params = new URLSearchParams(window.location.search);
                    params.set(selector.replace('#', '').replace('_filter', ''), filterElement.value);
                    window.location.search = params.toString();
                });
            }
        });

        const clearButton = document.getElementById('clear_filters');
        if (clearButton) {
            clearButton.addEventListener('click', () => {
                window.location.href = "{{ url_for('tasks.list_tasks') }}";
            });
        }
    },

    initTaskInteraction: function () {
        /* document.addEventListener("click", async (event) => {
            if (event.target.classList.contains("task-open-link")) {
                event.preventDefault();
                const taskId = event.target.dataset.taskId;
                try {
                    await openTaskModal(taskId); // Ensure `openTaskModal` is defined and imported
                } catch (error) {
                    console.error("Error opening task modal:", error);
                }
            }
        }); */
    },

    initNewTaskModal: function () {
        const newTaskButton = document.getElementById("newTaskButton");
        if (newTaskButton) {
            newTaskButton.addEventListener("click", () => {
                const taskForm = document.getElementById("taskForm");
                if (taskForm) {
                    taskForm.reset();
                }
                const taskIdField = document.getElementById("task-id");
                const modalLabel = document.getElementById("createTaskModalLabel");
                if (taskIdField) taskIdField.value = "";
                if (modalLabel) modalLabel.textContent = "Create Task";

                TaskManager.rebuildTaskParentMap(); // Reflect the new parent-child relationships
            });
        }
    },

    initSaveTask: function () {
        console.log("Initializing Save Task functionality..."); // Debugging
        const taskForm = document.getElementById("taskForm");
        if (taskForm) {
            // Remove existing event listener to avoid duplicates
            taskForm.removeEventListener("submit", this.handleTaskSave);
    
            // Add new submit event listener
            taskForm.addEventListener("submit", this.handleTaskSave.bind(this));
            console.log("Save Task functionality initialized.");
        } else {
            console.warn("Task form (#taskForm) not found during initialization of save logic.");
        }
    },
    
    handleTaskSave: async function (event) {
        event.preventDefault(); // Prevent default form submission
    
        const taskForm = event.target; // Get the form from the event
        const formData = new FormData(taskForm); // Gather form data
        const payload = Object.fromEntries(formData); // Convert form data to an object

        console.log("Payload prepared:", payload);
    
        // Frontend Validation
        if (!payload.title || payload.title.trim() === "") {
            alert("Task title is required.");
            console.error("Task title validation failed.");
            return;
        }
    
        // Handle parent_id properly
        const parentTaskField = document.getElementById("taskParent");
        if (parentTaskField) {
            payload['parent_id'] = parentTaskField.value || null; // Assign `null` if no parent selected
        }
    
        // Map the `title` field to `name` for backend compatibility
        payload['name'] = payload['title'];
    
        try {
            // Send the payload to the backend
            const response = await fetch("/api/tasks", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRFToken": this.csrfToken, // Include CSRF token
                },
                body: JSON.stringify(payload),
            });
    
            if (response.ok) {
                const result = await response.json();
                console.log("Task saved successfully:", result);
    
                // Reload the table
                window.location.reload(); // Reload the entire page
                window.location.href = `/tasks#task-${result.task_id}`;
                highlightTask(result.task_id); // Highlight the saved task

            } else {
                const errorData = await response.json();
                console.error("Error saving task:", errorData);
                alert(`Failed to save the task: ${errorData.message || "Unknown error"}`);
            }
        } catch (error) {
            console.error("Unexpected error saving task:", error);
            alert("An unexpected error occurred. Please try again.");
        }
    },

/* ======================== Drag and Drop section ======================== */


    /**
     * Initializes the `taskParentMap` from the DOM.
     */
    initTaskParentMap: function () {
        console.log("Initializing Task Parent Map...");
        this.taskParentMap.clear(); // Clear the map to ensure a fresh start

        // Iterate over all task rows to populate the map
        document.querySelectorAll("tr[data-task-id]").forEach((row) => {
            const taskId = parseInt(row.dataset.taskId, 10);
            const parentId = row.dataset.parentId ? parseInt(row.dataset.parentId, 10) : null;
            this.taskParentMap.set(taskId, parentId);
        });

        console.log("Task Parent Map initialized:", Array.from(this.taskParentMap.entries()));
    },

    /**
     * Dynamically updates the `taskParentMap` when a task's parent changes.
     * @param {number} taskId - ID of the task to update.
     * @param {number|null} parentId - New parent ID, or `null` if no parent.
     */
    updateTaskParentMap: function (taskId, parentId) {
        console.log(`Updating Task Parent Map: Task ${taskId} -> Parent ${parentId}`);
        this.taskParentMap.set(taskId, parentId);
    },

    /**
     * Rebuilds the `taskParentMap` to reflect dynamic changes in the DOM.
     * This should be called after drag-and-drop or task deletion.
     */
    rebuildTaskParentMap: function () {
        console.log("Rebuilding Task Parent Map...");
        this.initTaskParentMap();
    },

    initDragAndDrop: function () {
        if (!this.csrfToken) {
            console.error("CSRF token is not set. Drag-and-drop cannot be initialized.");
            return;
        }
        if (window.isDragAndDropInitialized) {
            console.log("Drag-and-drop is already initialized.");
            return;
        }

        console.log("Initializing drag-and-drop within TaskManager...");
        console.log("CSRF Token in initDragAndDrop:", this.csrfToken);
        const tableBody = document.querySelector("tbody");
        if (!tableBody) {
            console.warn("Task table body not found for drag-and-drop initialization");
            return;
        }

        // Initialize Sortable.js for drag-and-drop functionality
        Sortable.create(tableBody, {
            handle: ".task-row", // Only draggable via `.task-row` elements
            animation: 150, // Smooth animation
            filter: ".task-open-link", // Prevent dragging on task links
            preventOnFilter: true, // Prevent drag if filtered element is clicked
            onEnd: async (event) => {
                try {
                    console.log("Drag-and-drop operation started...");
                    const draggedRow = event.item; // The row that was dragged
                    const taskId = parseInt(draggedRow.dataset.taskId, 10);
                    const parentRow = draggedRow.previousElementSibling; // Assumes parent is the previous sibling
                    const parentId = parentRow ? parseInt(parentRow.dataset.taskId, 10) : null;

                    // Update TaskParentMap only
                    this.updateTaskParentMap(taskId, parentId);

                    console.log("Updated Task Parent Map:", Array.from(this.taskParentMap.entries()));

                    // Prepare and send the payload
                    // Remove this? const rows = Array.from(event.from.querySelectorAll(".task-row"));
                    const reorderedTasks = rows.map((row, index) => ({
                        id: parseInt(row.dataset.taskId, 10),
                        sort_order: index + 1,
                        parent_id: this.taskParentMap.get(parseInt(row.dataset.taskId, 10)),
                    }));

                    console.log("Final Payload (Before Submission):", JSON.stringify(reorderedTasks));
                    const response = await fetch("/tasks/reorder_subtasks", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "X-CSRFToken": this.csrfToken,
                        },
                        body: JSON.stringify({ ordered_tasks: reorderedTasks }),
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error("Error reordering tasks:", errorData);
                        alert(`Failed to reorder tasks: ${errorData.message || "Unknown error"}`);
                    } else {
                        const data = await response.json();
                        console.log("Task reordering successful:", data);
                    }
                } catch (error) {
                    console.error("Error during drag-and-drop operation:", error);
                    alert("An unexpected error occurred while reordering tasks.");
                }
            }, // End of onEnd callback
        });

    window.isDragAndDropInitialized = true;
    console.log("Drag-and-drop initialized successfully.");
}};